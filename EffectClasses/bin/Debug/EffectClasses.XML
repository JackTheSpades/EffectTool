<?xml version="1.0"?>
<doc>
    <assembly>
        <name>EffectClasses</name>
    </assembly>
    <members>
        <member name="T:EffectClasses.Registers">
            <summary>
            Contains various registers the SNES can use for DMA/HDMA
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.Brightness">
            <summary>
            SNES Brigtness register.
            <para>Format: ----bbbb</para>
            <para>0 = Total darkness, F = full brightness</para>
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.Pixelation">
            <summary>
            Screen Pixelation
            <para>xxxxDCBA</para>
            <para>A/B/C/D = Affect BG1/BG2/BG3/BG4</para>
            <para>xxxx = pixel size, 0=1x1, F=16x16</para>
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.BG1Horizontal">
            <summary>
            ------xx xxxxxxxx
            x = The BG offset, 10 bits. Only durring mode 0-6
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.BG1Vertical">
            <summary>
            ------xx xxxxxxxx
            x = The BG offset, 10 bits. Only durring mode 0-6
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.BG2Horizontal">
            <summary>
            ------xx xxxxxxxx
            x = The BG offset, 10 bits. Only durring mode 0-6
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.BG2Vertical">
            <summary>
            ------xx xxxxxxxx
            x = The BG offset, 10 bits. Only durring mode 0-6
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.BG3Horizontal">
            <summary>
            ------xx xxxxxxxx
            x = The BG offset, 10 bits. Only durring mode 0-6
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.BG3Vertical">
            <summary>
            ------xx xxxxxxxx
            x = The BG offset, 10 bits. Only durring mode 0-6
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.BG4Horizontal">
            <summary>
            ------xx xxxxxxxx
            x = The BG offset, 10 bits. Only durring mode 0-6
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.BG4Vertical">
            <summary>
            ------xx xxxxxxxx
            x = The BG offset, 10 bits. Only durring mode 0-6
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.WindowMaskSettingBG1BG2">
            <summary>
            Handles inverting and enabling for BG1 and BG2 on windows 1 and 2
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.WindowMaskSettingBG3BG4">
            <summary>
            Handles inverting and enabling for BG3 and BG4 on windows 1 and 2
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.WindowMaskSettingOBJColor">
            <summary>
            Handles inverting and enabling for OBJ and Color on windows 1 and 2
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.WindowMask1Left">
            <summary>
            The left position of the 1st window to mask the screen
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.WindowMask1Right">
            <summary>
            The right position of the 1st window to mask the screen
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.WindowMask2Left">
            <summary>
            The left position of the 2nd window to mask the screen
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.WindowMask2Right">
            <summary>
            The right position of the 2nd window to mask the screen
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.WindowingLogicBgs">
            <summary>
            44332211
            Logic for overlapping windows on BGs
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.WindowingLogicObjColor">
            <summary>
            ----ccoo
            Logic for overlapping windows on color and objects
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.MainScreenDesignation">
            <summary>
            ---o4321
            Enable BGx or OBJ on the mainscreen
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.SubScreenDesignation">
            <summary>
            ---o4321
            Enable BGx or OBJ on the subscreen
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.MainScreenWindow">
            <summary>
            ---o4321
            Enable window on mainscreen for BGx/OBJ
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.SubScreenWindow">
            <summary>
            ---o4321
            Enable window on subscreen for BGx/OBJ
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.FixedColor">
            <summary>
            bgrccccc
            b/g/r = Which color plane(s) to set the intensity for.
            ccccc = Color intensity.
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.DMAMode">
            <summary>
            DMA Control for Channel 0. Add 16 per channel
            <para>da-ifttt</para>
            <para>d = Transfer Direction. Clear: <![CDATA[CPU > PPU. Set: CPU < PPU]]></para>
            <para>a = HDMA Addressing Mode. Set: Indirect HDMA</para>
            <para>i = DMA Address Increment. Clear: increment, Set: decrement</para>
            <para>f = DMA Fixed Transfer. Set: Address not adjusted</para>
            <para>ttt = Transfer Mode. p | p,p+1 | p,p | p,p,p+1,p+1 | p,p+1,p+2,p+3 | p,p+1,p,p+1</para>
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.DMATarget">
            <summary>
            DMA Destination Register Channel 0. Add 16 per channel.
            pppppppp 
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.DMALowByte">
            <summary>
            DMA Source Address for Channel 0 low byte. Add 16 per channel.
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.DMAHighByte">
            <summary>
            DMA Source Address for Channel 0 high byte. Add 16 per channel
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.DMABankByte">
            <summary>
            DMA Source Address for Channel 0 bank byte. Add 16 per channel
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.DMASizeLow">
            <summary>
            DMA Size/HDMA Indirect Address low byte channel 0. Add 16 per channel.
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.DMASizeHigh">
            <summary>
            DMA Size/HDMA Indirect Address high byte channel 0. Add 16 per channel.
            </summary>
        </member>
        <member name="P:EffectClasses.Registers.HDMAIndirectBank">
            <summary>
            DMA Size/HDMA Indirect Address low byte channel 0. Add 16 per channel.
            </summary>
        </member>
        <member name="T:EffectClasses.RAM">
            <summary>
            Contains various Dictionaries with a boolean key.
            <c>True</c> makes it return the SA-1 address, while <c>false</c> returns the normal one.
            </summary>
        </member>
        <member name="F:EffectClasses.RAM.SA1">
            <summary>
            Use SA-1
            </summary>
        </member>
        <member name="P:EffectClasses.RAM.FrameCounter">
            <summary>
            SMW Frame Counter
            </summary>
        </member>
        <member name="P:EffectClasses.RAM.ColorMathSetting">
            <summary>
            CGADSUB settings. 
            <para>Format: shbo4321</para>
            <para>s = 0 for adding , 1 for subtracting color layer</para>
            <para>h = half-color enable</para>
            <para>b = backdrop enable</para>
            <para>o = object (aka sprite) enable</para>
            <para>4321 = enable Layer 4, 3, 2, 1 (Layer 3 is only affected below the status bar)</para>
            <para>Mirror of SNES register $2131</para>
            </summary>
        </member>
        <member name="P:EffectClasses.RAM.WindowMaskSettingBG1BG2">
            <summary>
            W12SEL
            <para>Format: ABCDabcd</para>
            <para>a = enable window 2 for BG1</para>
            <para>b = invert window 2 for BG1</para>
            <para>c = enable window 1 for BG1</para>
            <para>d = invert window 1 for BG1</para>
            <para>capital letters for BG2</para>
            <para>Mirror of SNES register $2123</para>
            </summary>
        </member>
        <member name="P:EffectClasses.RAM.WindowMaskSettingBG3BG4">
            <summary>
            W34SEL
            <para>Format: ABCDabcd</para>
            <para>a = enable window 2 for BG3</para>
            <para>b = invert window 2 for BG3</para>
            <para>c = enable window 1 for BG3</para>
            <para>d = invert window 1 for BG3</para>
            <para>capital letters for BG4</para>
            <para>Mirror of SNES register $2124</para>
            </summary>
        </member>
        <member name="P:EffectClasses.RAM.WindowMaskSettingOBJColor">
            <summary>
            WOBJSEL
            <para>Format: ABCDabcd</para>
            <para>a = enable window 2 for OBJ</para>
            <para>b = invert window 2 for OBJ</para>
            <para>c = enable window 1 for OBJ</para>
            <para>d = invert window 1 for OBJ</para>
            <para>capital letters for color</para>
            <para>Mirror of SNES register $2125</para>
            </summary>
        </member>
        <member name="P:EffectClasses.RAM.ColorAdditionSelect">
            <summary>
            $44: CGWSEL settings. 
            <para>Format: ccmm--sd</para>
            <para>cc = Clip to black before math. 00-Never, 01-Outside, 10-Inside, 11-Always</para>
            <para>mm = Prevent color math. 00-Never, 01-Outside, 10-Inside, 11-Always</para>
            <para>s = Add subscreen instead of fixed color</para>
            <para>d = Direct color mode for 256-color BGs</para>
            <para>Mirror of SNES register $2130</para>
            </summary>
        </member>
        <member name="P:EffectClasses.RAM.MainScreenAndWindowDesignation">
            <summary>
            TM/TMW: 
            <para>format: ---o2134</para>
            <para>o = Object layer</para>
            <para>1/2/3/4 = Layer 1/2/3/4</para>
            <para>Mirror of SNES register $212C and $212E</para>
            </summary>
        </member>
        <member name="P:EffectClasses.RAM.SubScreenAndWindowDesignation">
            <summary>
            TS/TSW: 
            <para>format: ---o2134</para>
            <para>o = Object layer</para>
            <para>1/2/3/4 = Layer 1/2/3/4</para>
            <para>Mirror of SNES register $212D and $212F</para>
            </summary>
        </member>
        <member name="P:EffectClasses.RAM.HDMAEnable">
            <summary>
            HDMA Channel Enable: 
            <para>abcdefgh</para>
            <para>a = Channel 7 .. h = Channel 0</para>
            <para>1 = Enable 0 = Disable.</para>
            <para>Mirror of SNES register $420C.</para>
            </summary>
        </member>
        <member name="P:EffectClasses.RAM.Layer1X">
            <summary>
            Layer 1 X position. 2 Bytes
            <para>Mirror of $210D</para>
            <para>Used for temporary storage to determine how much the screen has moved horizontally in the current frame.</para>
            </summary>
        </member>
        <member name="P:EffectClasses.RAM.Layer1Y">
            <summary>
            Layer 1 Y position. 2 Bytes
            <para>Mirror of $210E</para>
            <para>Used for temporary storage to determine how much the screen has moved vertically in the current frame.</para>
            </summary>
        </member>
        <member name="P:EffectClasses.RAM.Layer2X">
            <summary>
            Layer 2 X position. 2 Bytes
            <para>Mirror of $210F</para>
            <para>Used for temporary storage to determine how much the screen has moved horizontally in the current frame.</para>
            </summary>
        </member>
        <member name="P:EffectClasses.RAM.Layer2Y">
            <summary>
            Layer 2 Y position. 2 Bytes
            <para>Mirror of $2110</para>
            <para>Used for temporary storage to determine how much the screen has moved vertically in the current frame.</para>
            </summary>
        </member>
        <member name="P:EffectClasses.RAM.Layer3X">
            <summary>
            Layer 3 X position. 2 Bytes
            <para>Mirror of $2111</para>
            <para>Used for temporary storage to determine how much the screen has moved horizontally in the current frame.</para>
            </summary>
        </member>
        <member name="P:EffectClasses.RAM.Layer3Y">
            <summary>
            Layer 3 Y position. 2 Bytes
            <para>Mirror of $2112</para>
            <para>Used for temporary storage to determine how much the screen has moved horizontally in the current frame.</para>
            </summary>
        </member>
        <member name="M:EffectClasses.BitmapEffects.OverlapImages(System.Drawing.Bitmap[])">
            <summary>
            Puts images ontop of each other and the later images will only be visible through transparent parts of the former images
            </summary>
            <param name="Images">The array containing all the images that will be overlapped. The former indizes will be ontop.</param>
            <returns>The merged image</returns>
        </member>
        <member name="M:EffectClasses.BitmapEffects.SingleOverlapImages(System.Drawing.Bitmap,System.Drawing.Bitmap)">
            <summary>
            Puts two images ontop of each other. Only where top is transparent bottom can be seen
            </summary>
            <param name="top">The Bitmap to put ontop of the other.</param>
            <param name="bottom">The Bitmap to put below the other.</param>
            <returns>A combined Bitmap of the given paramteres</returns>
        </member>
        <member name="M:EffectClasses.BitmapEffects.MergeImages_(System.Drawing.Bitmap[])">
            <summary>
            Adds every pixel of the images with each corresponding pixel.
            </summary>
            <param name="images">The array of images that will be added together.</param>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.BitmapEffects.MergeImages(System.Drawing.Bitmap[])">
            <summary>
            Adds every pixel of the images with each corresponding pixel.
            </summary>
            <param name="Images">The array of images that will be added together.</param>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.BitmapEffects.Invert(System.Drawing.Bitmap)">
            <summary>
            Invertes the colors of a bitmap
            </summary>
            <param name="source">The Bitmap to be inverted</param>
            <returns>The inverted Bitmap</returns>
        </member>
        <member name="M:EffectClasses.BitmapEffects.BlackWhite(System.Drawing.Bitmap,System.Single)">
            <summary>
            Creates a pure black and white image (no gray scales)
            </summary>
            <param name="source">The image to be converted</param>
            <param name="threshold">The threshold of whether colors should become black or white.</param>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.BitmapEffects.Render(System.Drawing.Bitmap,System.Double,System.Drawing.Point[])">
            <summary>
            Makes part of an image transparent. Given a number of starting points, every pixel connected to the start
            and withing a certain percentage will become transparent.
            </summary>
            <param name="image">The image to be rendered</param>
            <param name="percent">How many percent within a pixel has to be given the startingpixel to be rendered</param>
            <param name="points">The list of points to start from</param>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.BitmapEffects.FromColor(System.Drawing.Color,System.Drawing.Size)">
            <summary>
            Creates a new Bitmap with defined size filled with a certain color.
            </summary>
            <param name="color">The color the Bitmap should be filled with.</param>
            <param name="size">The size of the Bitmap</param>
            <returns>A Bitmap filled with the desired color</returns>
        </member>
        <member name="M:EffectClasses.BitmapEffects.FromColor(System.Drawing.Color,System.Int32,System.Int32)">
            <summary>
            Creates a new Bitmap with defined size filled with a certain color.
            </summary>
            <param name="color">The color the Bitmap should be filled with.</param>
            <param name="width">The width of the Bitmap</param>
            <param name="height">The height of the Bitmap</param>
            <returns>A Bitmap filled with the desired color</returns>
        </member>
        <member name="M:EffectClasses.BitmapEffects.MoveLine(System.Int32,System.Int32,System.Int32,System.Drawing.Bitmap,EffectClasses.Orientation)">
            <summary>
            Rotiert einen bestimmten Bereich einer Bitmap nach links und 
            </summary>
            <param name="initHeight">Die Y Höhe ab der die Zeilen verschoben werden</param>
            <param name="bandwidth">Wie viele Zeilen verschoben werden sollen</param>
            <param name="moving">Um wie viele Pixel die Bitmap nach links verschoben werden soll</param>
            <param name="original">Die Bitmap die verschoben werden soll</param>
            <param name="direction">Die Richtung in die sich der ausgewählte Teil bewegen soll</param>
            <returns>Die neue Bitmap mit der entsprechend verschobenen Linien</returns>
        </member>
        <member name="M:EffectClasses.BitmapEffects.MoveLineLeft(System.Int32,System.Int32,System.Int32,System.Drawing.Bitmap)">
            <summary>
            Moves a line to the right in an image and loops it back at the other side.
            </summary>
            <param name="offset">The line to start the moving in. Start counting from the top</param>
            <param name="height">The height of the line to be moved in pixel</param>
            <param name="pixel">The number of pixel to move the line to the right</param>
            <param name="original">The image that will have a line moved</param>
        </member>
        <member name="M:EffectClasses.BitmapCollection.Save(EffectClasses.BitmapCollection,System.String)">
            <summary>
            Saves a BitmapCollection to file.
            </summary>
            <param name="Collection">The collection to save</param>
            <param name="FilePath">The path to save to</param>
        </member>
        <member name="M:EffectClasses.BitmapCollection.Load(System.String)">
            <summary>
            Loads a BitmapCollection from a file.
            </summary>
            <param name="FilePath">The path to the file to open</param>
            <returns>The opened BitmapCollection</returns>
        </member>
        <member name="M:EffectClasses.BitmapCollection.Load(System.Byte[])">
            <summary>
            Loads a BitmapCollection from a file.
            </summary>
            <param name="FilePath">The path to the file to open</param>
            <returns>The opened BitmapCollection</returns>
        </member>
        <member name="P:EffectClasses.BitmapCollection.BG1">
            <summary>
            The first object layer. BG2/BG3/BG4 will appear behind it. Used in any BG Mode
            </summary>
        </member>
        <member name="P:EffectClasses.BitmapCollection.BG2">
            <summary>
            The second object layer BG3/BG4 will appear behind it. Used in BG Mode 0 - 5
            </summary>
        </member>
        <member name="P:EffectClasses.BitmapCollection.BG3">
            <summary>
            The third object layer. BG4 will appear behind it. Used in BG Mode 0 and 1
            </summary>
        </member>
        <member name="P:EffectClasses.BitmapCollection.BG4">
            <summary>
            The fourth and last object layer. Only used in BG Mode 0
            </summary>
        </member>
        <member name="P:EffectClasses.BitmapCollection.OBJ">
            <summary>
            The sprite layer. All other BGs will appear behind it
            </summary>
        </member>
        <member name="P:EffectClasses.BitmapCollection.Name">
            <summary>
            The name of the collection
            </summary>
        </member>
        <member name="P:EffectClasses.BitmapCollection.FixedColor">
            <summary>
            The solid color at the very last layer.
            </summary>
        </member>
        <member name="T:EffectClasses.ColorMathMode">
            <summary>
            Sets the circumstances for color math. Whether it will be added/substracted. Halfed and which layers are to participate
            </summary>
        </member>
        <member name="F:EffectClasses.ColorMathMode.Substract">
            <summary>
            Subscreen or fixed color will be substracted from the mainscreen
            </summary>
        </member>
        <member name="F:EffectClasses.ColorMathMode.Half">
            <summary>
            Equation will be halfed before clipping
            </summary>
        </member>
        <member name="F:EffectClasses.ColorMathMode.Backdrop">
            <summary>
            Backdrop will be added. It represents color 0 of CGRAM
            </summary>
        </member>
        <member name="F:EffectClasses.ColorMathMode.OBJ">
            <summary>
            Sprites (objects) on the main screen will participate in color math
            </summary>
        </member>
        <member name="F:EffectClasses.ColorMathMode.BG4">
            <summary>
            Layer 4 on the main screen will participate in color math
            </summary>
        </member>
        <member name="F:EffectClasses.ColorMathMode.BG3">
            <summary>
            Layer 3 on the main screen will participate in color math
            </summary>
        </member>
        <member name="F:EffectClasses.ColorMathMode.BG2">
            <summary>
            Layer 2 on the main screen will participate in color math
            </summary>
        </member>
        <member name="F:EffectClasses.ColorMathMode.BG1">
            <summary>
            Layer 1 on the main screen will participate in color math
            </summary>
        </member>
        <member name="T:EffectClasses.ScreenDesignation">
            <summary>
            Which layers will show up on screen
            </summary>
        </member>
        <member name="F:EffectClasses.ScreenDesignation.OBJ">
            <summary>
            Sprites (objects) will be on the layer
            </summary>
        </member>
        <member name="F:EffectClasses.ScreenDesignation.BG4">
            <summary>
            Layer 4 will be on the layer
            </summary>
        </member>
        <member name="F:EffectClasses.ScreenDesignation.BG3">
            <summary>
            Layer 3 will be on the layer
            </summary>
        </member>
        <member name="F:EffectClasses.ScreenDesignation.BG2">
            <summary>
            Layer 2 will be on the layer
            </summary>
        </member>
        <member name="F:EffectClasses.ScreenDesignation.BG1">
            <summary>
            Layer 1 will be on the layer
            </summary>
        </member>
        <member name="T:EffectClasses.WindowMaskLogic">
            <summary>
            What to do when the two windows overlap
            </summary>
        </member>
        <member name="F:EffectClasses.WindowMaskLogic.Or">
            <summary>
            The pixel will be masked if one or more widows reach it
            </summary>
        </member>
        <member name="F:EffectClasses.WindowMaskLogic.And">
            <summary>
            The pixel will be masked if both windows reach it
            </summary>
        </member>
        <member name="F:EffectClasses.WindowMaskLogic.Xor">
            <summary>
            The pixel will be masked if one of the other (not both) windows reach it
            </summary>
        </member>
        <member name="F:EffectClasses.WindowMaskLogic.XNor">
            <summary>
            The pixel will be masked if none or both windows reach it.
            </summary>
        </member>
        <member name="T:EffectClasses.WindowingLayers">
            <summary>
            Layers that can participate in color math
            </summary>
        </member>
        <member name="F:EffectClasses.WindowingLayers.OBJ">
            <summary>
            
            </summary>
        </member>
        <member name="T:EffectClasses.ColorMath">
            <summary>
            
            </summary>
        </member>
        <member name="F:EffectClasses.ColorMath.StatusBarHeight">
            <summary>
            0x00493 - $00:8293
            The height of the status bar that will appear before any other layer and is not affected by color math.
            </summary>
        </member>
        <member name="M:EffectClasses.ColorMath.ApplyColorMath(System.Drawing.Bitmap,System.Drawing.Bitmap,EffectClasses.ColorMathMode,System.Drawing.Bitmap,EffectClasses.ColorAdditionalSelectOptions,EffectClasses.ColorAdditionalSelectOptions)">
            <summary>
            Applies the color Math to a certain Bitmap.
            Depending on the mode the screens will be added or substracted and the result may be halfed
            </summary>
            <param name="Layer">The layer that will be color mathed (Is that a word?)</param>
            <param name="SubScreen">The subscreen that will be mathed to the layer</param>
            <param name="Mode">f</param>
            <returns>The final image</returns>
        </member>
        <member name="M:EffectClasses.ColorMath.SetFixedColor(System.Drawing.Color)">
            <summary>
            Sets the FixedColor property based on a desired color.
            </summary>
            <param name="color">The color for the Bitmap</param>
        </member>
        <member name="M:EffectClasses.ColorMath.SetBackdrop(System.Drawing.Color)">
            <summary>
            Sets the FixedColor property based on a desired color.
            </summary>
            <param name="color">The color for the Bitmap</param>
        </member>
        <member name="M:EffectClasses.ColorMath.GetScreen">
            <summary>
            Gets the screen as it would be displayed by the SNES.
            </summary>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.ColorMath.MergeMasks(System.Drawing.Bitmap,System.Drawing.Bitmap,EffectClasses.WindowMaskLogic)">
            <summary>
            Combines two black/white masks in a new bitmap
            </summary>
            <param name="mask1">The first mask for the merge</param>
            <param name="mask2">The second mask for the merge</param>
            <param name="logic">How to merge the masks</param>
            <returns>The merged masks</returns>
        </member>
        <member name="P:EffectClasses.ColorMath.BG1">
            <summary>
            The first object layer. BG2/BG3/BG3 will appear behind it. Used in any BG Mode
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.BG2">
            <summary>
            The second object layer BG3/BG4 will appear behind it. Used in BG Mode 0 - 5
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.BG3">
            <summary>
            The third object layer. BG4 will appear behind it. Used in BG Mode 0 and 1
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.BG4">
            <summary>
            The fourth and last object layer. Only used in BG Mode 0
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.OBJ">
            <summary>
            The sprite layer. All other BGs will appear behind it
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.FixedColor">
            <summary>
            $2132 Requires a Bitmap to also work with HDMA set colors
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.Backdrop">
            <summary>
            The Backdrop (aka color 0). It's the backcolor of the main screen. Uses a Bitmap for HDMA
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.WindowingMask1">
            <summary>
            A black/white mask for the windowing used in window 1.
            This will only influence the display from GetScreen but not the code
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.WindowingMask2">
            <summary>
            A black/white mask for the windowing used in window 1.
            This will only influence the display from GetScreen but not the code
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.Collection">
            <summary>
            The collection of all the BGs and the object layer.
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.MainScreenDesignation">
            <summary>
            This value will later be used for $212C.
            ---o4321
            It sets which BGs are on the mainscreen.
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.SubScreenDesignation">
            <summary>
            This value will later be used for $212D.
            ---o4321
            It sets which BGs are on the subscreen.
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.MainScreenWindowMaskDesignation">
            <summary>
            This value will later be used for $212E.
            ---o4321
            It sets which BGs on the mainscreen the windowing will be used on.
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.SubScreenWindowMaskDesignation">
            <summary>
            This value will later be used for $212F.
            ---o4321
            It sets which BGs on the subscreen the windowing will be used on.
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.MaskLogicBgs">
            <summary>
            The window mask logic that will be applied for the BGs.
            <para>Value used on register $212A</para>
            <para>Format: 44332211</para>
            <para>00 = Or, 01 = And, 10 = Xor, 11 = XNor</para>
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.MaskLogicObjCol">
            <summary>
            The window mask logic that will be applied for the color screen and objects.
            <para>Value used on register $212B</para>
            <para>Format: ----ccoo</para>
            <para>00 = Or, 01 = And, 10 = Xor, 11 = XNor</para>
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.Window1Inverted">
            <summary>
            When flag for a layer is set the WindowingMask1 will be inverted before applying.
            <para>Controls various bits in $2123 - $2125</para>
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.Window2Inverted">
            <summary>
            When flag for a layer is set the WindowingMask2 will be inverted before applying.
            <para>Controls various bits in $2123 - $2125</para>
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.Window1Enabled">
            <summary>
            When flag for a layer is set the WindowingMask1 will be used on that layer.
            <para>Controls various bits in $2123 - $2125</para>
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.Window2Enabled">
            <summary>
            When flag for a layer is set the WindowingMask2 will be used on that layer.
            <para>Controls various bits in $2123 - $2125</para>
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.ColorMathDesignation">
            <summary>
            Which BGs should participate in color math and how.
            <para>Value used on register $2131, $40</para>
            <para>Format: shbo4321</para>
            <para>s = add 0 / substract 1</para>
            <para>h = half after calculation</para>
            <para>bo4321 = enable BG1/BG2/BG3/BG4/OBJ/Backdrop</para>
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.ClipToBlack">
            <summary>
            Sets pixels on the mainscreen to black before doing color math
            Controlled by bit 7-6 of $2130
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.PreventColorMath">
            <summary>
            Doesn't run color math if set
            Controlled by bit 5-4 of $2130
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.AddColor">
            <summary>
            Whether the final screen will add the subscreen (false) or the fixed color (true).
            Controlled by bit 1 of $2130
            </summary>
        </member>
        <member name="P:EffectClasses.ColorMath.Hide">
            <summary>
            Any flag in this will not be added in the GetScreen() neither for sub nor for main screen
            </summary>
        </member>
        <member name="T:EffectClasses.HDMA">
            <summary>
            The basic class all HDMA classes inherit from. It describes basic methods and members
            </summary>
        </member>
        <member name="F:EffectClasses.HDMA.Scanlines">
            <summary>
            The normal amount of scanlines a SNES screen has
            </summary>
        </member>
        <member name="M:EffectClasses.HDMA.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:EffectClasses.HDMA.SetChannel(System.Windows.Forms.RadioButton,System.Windows.Forms.RadioButton,System.Windows.Forms.RadioButton)">
            <summary>
            Sets the Channel according to a one out of three choice from RadioButtons
            </summary>
            <param name="Ch3">RadioButton that when checked sets channel 3</param>
            <param name="Ch4">RadioButton that when checked sets channel 4</param>
            <param name="Ch5">RadioButton that when checked sets channel 5</param>
        </member>
        <member name="M:EffectClasses.HDMA.SetChannel(System.Windows.Forms.ComboBox)">
            <summary>
            Sets the channel according to the slected value.
            </summary>
            <param name="Cmbox">The combobox that has the channel selected.</param>
        </member>
        <member name="M:EffectClasses.HDMA.CountROMBytes">
            <summary>
            Counts how many bytes of ROM the table takes up
            </summary>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.HDMA.CountRAMBytes">
            <summary>
            Counts how many bytes of RAM the table takes up
            </summary>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.HDMA.Code">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.HDMA.Code(System.Int32)">
            <summary>
            
            </summary>
            <param name="channel"></param>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.HDMA.Code(EffectClasses.HDMATable)">
            <summary>
            
            </summary>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.HDMA.Code(System.Int32,EffectClasses.HDMATable,System.Boolean)">
            <summary>
            
            </summary>
            <param name="channel"></param>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.HDMA.GetMode(System.Boolean,EffectClasses.DMAMode)">
            <summary>
            Builds the mode value used for HDMA transfer. The value's stored to $43x0
            </summary>
            <param name="indirect">Used only in HDMA. Whether the table shown by the pointers has the values or addresses to the values
            <para><c>True</c> if the table has addresses</para></param>
            <param name="mode">How often and where bytes should be written to the register</param>
            <returns>The compiled byte</returns>
        </member>
        <member name="M:EffectClasses.HDMA.GetMode(EffectClasses.DMADirection,System.Boolean,System.Boolean,System.Boolean,EffectClasses.DMAMode)">
            <summary>
            Builds the mode value used for DMA/HDMA transfer. The value's stored to $43x0
            </summary>
            <param name="direction">Which direction the transfer should go to/come from</param>
            <param name="indirect">Used only in HDMA. Whether the table shown by the pointers has the values or addresses to the values
            <para><c>True</c> if the table has addresses</para></param>
            <param name="increment">Used only in DMA. Whether the address will be incremented or decremented
            <c>True</c> if the address should be decremented</param>
            <param name="fixedtrans">When set, the address will not be adjusted</param>
            <param name="mode">How often and where bytes should be written to the register</param>
            <returns>The compiled byte</returns>
        </member>
        <member name="P:EffectClasses.HDMA.Channel">
            <summary>
            Which Channel the HDMA will run in, assuming it has only one
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if a value out of the range of 0-7 is entered</exception>
        </member>
        <member name="P:EffectClasses.HDMA.UsesMain">
            <summary>
            Whether the HDMA has a MAIN routine or just INIT
            </summary>
        </member>
        <member name="P:EffectClasses.HDMA.FreeRAM">
            <summary>
            The free RAM address the HDMA stores date to in case it needs it.
            </summary>
        </member>
        <member name="P:EffectClasses.HDMA.Table">
            <summary>
            The table the HDMA effect is based on
            </summary>
        </member>
        <member name="M:EffectClasses.AnimatedHDMA.StaticPic">
            <summary>
            Creates a base image with the preset setting of Amplitede and Width using the Original member
            </summary>
            <returns>The according to the settings disordered image</returns>
        </member>
        <member name="M:EffectClasses.AnimatedHDMA.NextAnimateFrame">
            <summary>
            Creates a Bitmap depending on the settings and the internal counter, which also get's increased at the end using the Original Member.
            </summary>
            <returns>Depending on the settings moved image.</returns>
        </member>
        <member name="M:EffectClasses.AnimatedHDMA.StaticPic(System.Drawing.Bitmap)">
            <summary>
            Creates a base image with the preset setting of Amplitede and Width
            </summary>
            <param name="basePic">The base for the disordered image</param>
            <returns>The according to the settings disordered image</returns>
        </member>
        <member name="M:EffectClasses.AnimatedHDMA.NextAnimateFrame(System.Drawing.Bitmap)">
            <summary>
            Creates a Bitmap depending on the settings and the internal counter, which also get's increased at the end.
            </summary>
            <param name="basePic">The still (unchanged) image.</param>
            <returns>Depending on the settings moved image.</returns>
        </member>
        <member name="M:EffectClasses.AnimatedHDMA.StartAnimation(EffectClasses.AnimatedImage)">
            <summary>
            Starts up the animation with a desired method as to what to do with the images for the animation.
            </summary>
            <param name="imgFunc"></param>
        </member>
        <member name="M:EffectClasses.AnimatedHDMA.StopAnimation">
            <summary>
            Halts the animation
            </summary>
        </member>
        <member name="P:EffectClasses.AnimatedHDMA.Original">
            <summary>
            The Image used for the effect
            </summary>
        </member>
        <member name="P:EffectClasses.AnimatedHDMA.Frame">
            <summary>
            Which Frame we're currently running.
            </summary>
        </member>
        <member name="P:EffectClasses.AnimatedHDMA.UsesMain">
            <summary>
            Whether or not the code uses the MAIN routine of uberASM.
            </summary>
        </member>
        <member name="E:EffectClasses.AnimatedHDMA.AnimationException">
            <summary>
            Event that occures when an exception happens during the animation.
            This is recommended to be used to cancel the animation.
            </summary>
        </member>
        <member name="M:EffectClasses.BrightnessHDMA.UseCollection">
            <summary>
            
            </summary>
        </member>
        <member name="M:EffectClasses.BrightnessHDMA.UpdateImage">
            <summary>
            Generates the EffectImage based on the setting of the Table.
            </summary>
        </member>
        <member name="M:EffectClasses.BrightnessHDMA.CountRAMBytes">
            <summary>
            How many bytes of RAM the code will require during it's runtime.
            </summary>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.BrightnessHDMA.CountROMBytes">
            <summary>
            How many bytes of ROM the code takes up after being inserted
            <para>Only counts the bytes of the table so far!!!</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.BrightnessHDMA.Code(System.Int32,EffectClasses.HDMATable,System.Boolean)">
            <summary>
            Calculates the code for the Brightness HDMA with the desired channel, Table and possibly SA-1 compatible
            </summary>
            <param name="channel"></param>
            <param name="table"></param>
            <param name="sa1"></param>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.BrightnessHDMA.MultiCode(EffectClasses.BrightnessHDMA[])">
            <summary>
            Calculates the code for overlapping multiple brightness gradients.
            <para>The final code will use the channel of the first BrightnessHDMA object passed.</para>
            </summary>
            <param name="hdma">An array of BrightnessHDMA object that will be overlapped for the final code.</param>
            <returns>The final code.</returns>
        </member>
        <member name="P:EffectClasses.BrightnessHDMA.DarknessPositions">
            <summary>
            A collection of all the positions and which darkness level they ought to have at that position.
            </summary>
        </member>
        <member name="P:EffectClasses.BrightnessHDMA.EffectImage">
            <summary>
            The drawn gradient effect
            </summary>
        </member>
        <member name="P:EffectClasses.BrightnessHDMA.UsesMain">
            <summary>
            Whether the code requires the MAIN code in uberASM.
            <para>Will always return false.</para>
            </summary>
        </member>
        <member name="M:EffectClasses.PixelationHDMA.Setup">
            <summary>
            Sets up the color math and calculates the values for the HDMA table based on the entries of Values
            </summary>
        </member>
        <member name="P:EffectClasses.PixelationHDMA.UsesMain">
            <summary>
            <c>True</c> if the code requires MAIN code from uberASM
            </summary>
        </member>
        <member name="P:EffectClasses.PixelationHDMA.EffectImage">
            <summary>
            The combined image of all the layers and the pixelated
            </summary>
        </member>
        <member name="P:EffectClasses.PixelationHDMA.OriginalImages">
            <summary>
            The collection of the original images for the layers
            </summary>
        </member>
        <member name="P:EffectClasses.PixelationHDMA.Values">
            <summary>
            The values for the pixelation for the layers
            </summary>
        </member>
        <member name="T:EffectClasses.LayerRegister">
            <summary>
            The layer (BG) position registers within the SNES
            </summary>
        </member>
        <member name="T:EffectClasses.WaveHDMA">
            <summary>
            The base class that all Wave effects inherit from.
            </summary>
        </member>
        <member name="M:EffectClasses.WaveHDMA.Reset">
            <summary>
            Resets internal variables and animation frames and starts calculating anew.
            </summary>
        </member>
        <member name="M:EffectClasses.WaveHDMA.StaticPic(System.Drawing.Bitmap)">
            <summary>
            Creates a base image with the preset setting of Amplitede and Width
            </summary>
            <param name="basePic">The base for the disordered image</param>
            <returns>The according to the settings disordered image</returns>
        </member>
        <member name="M:EffectClasses.WaveHDMA.NextAnimateFrame(System.Drawing.Bitmap)">
            <summary>
            Creates a Bitmap depending on the settings and the internal counter, which also get's increased at the end.
            </summary>
            <param name="basePic">The still (unchanged) image.</param>
            <returns>Depending on the settings moved image.</returns>
        </member>
        <member name="M:EffectClasses.WaveHDMA.Code(System.Int32,EffectClasses.HDMATable,System.Boolean)">
            <summary>
            Generates the code for the desired effect
            </summary>
            <param name="channel"></param>
            <param name="table"></param>
            <param name="sa1"></param>
            <returns></returns>
        </member>
        <member name="P:EffectClasses.WaveHDMA.Direction">
            <summary>
            Which direction the waves go in.
            </summary>
        </member>
        <member name="P:EffectClasses.WaveHDMA.Amplitude">
            <summary>
            Sets how strong the movement is.
            </summary>
        </member>
        <member name="P:EffectClasses.WaveHDMA.Width">
            <summary>
            Sets how thick one of the moving sections is (in a sine thiw would be omage)
            </summary>
        </member>
        <member name="P:EffectClasses.WaveHDMA.Speed">
            <summary>
            Regulates the speed at which the ampilitude runs.
            That is to say, every 1/x runs the image changes and for the code how many frames to wait.
            (in a sine, this would be the frequanzy)
            </summary>
        </member>
        <member name="P:EffectClasses.WaveHDMA.Layers">
            <summary>
            Which register the effect code should work on
            </summary>
        </member>
        <member name="P:EffectClasses.WaveHDMA.EnabledWaveCollection">
            <summary>
            
            </summary>
        </member>
        <member name="P:EffectClasses.WaveHDMA.EnableTable">
            <summary>
            Enables the content of EnableWaveCollection to be used for the animation.
            </summary>
        </member>
        <member name="M:EffectClasses.WaveXHDMA.#ctor">
            <summary>
            Creates a new instance for WaveHDMA with the layer preset on Layer 2.
            </summary>
        </member>
        <member name="M:EffectClasses.WaveXHDMA.#ctor(System.Drawing.Bitmap)">
            <summary>
            Creates a new instance for WaveHDMA with an image to be used for the animation and the layer preset on Layer 2.
            </summary>
            <param name="original">The image to use for the animation</param>
        </member>
        <member name="P:EffectClasses.WaveXHDMA.Layers">
            <summary>
            Which register to use for the effect in the code
            </summary>
        </member>
        <member name="P:EffectClasses.WaveXHDMA.Direction">
            <summary>
            Which direction the waves go in.
            </summary>
        </member>
        <member name="M:EffectClasses.WaveYHDMA.#ctor">
            <summary>
            Creates a new instance for WaveHDMA with the layer preset on Layer 2.
            </summary>
        </member>
        <member name="M:EffectClasses.WaveYHDMA.#ctor(System.Drawing.Bitmap)">
            <summary>
            Creates a new instance for WaveHDMA with an image to be used for the animation and the layer preset on Layer 2.
            </summary>
            <param name="original">The image to use for the animation</param>
        </member>
        <member name="P:EffectClasses.WaveYHDMA.Layers">
            <summary>
            Which register to use for the effect in the code
            </summary>
        </member>
        <member name="P:EffectClasses.WaveYHDMA.Direction">
            <summary>
            Which direction the waves go in.
            </summary>
        </member>
        <member name="T:EffectClasses.ASMException">
            <summary>
            
            </summary>
        </member>
        <member name="M:EffectClasses.ASMException.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:EffectClasses.ASMException.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:EffectClasses.ASMException.#ctor(System.String,System.Exception)">
            <summary>
            
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:EffectClasses.ASMException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:EffectClasses.RAMException">
            <summary>
            
            </summary>
        </member>
        <member name="M:EffectClasses.RAMException.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:EffectClasses.RAMException.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:EffectClasses.RAMException.#ctor(System.String,System.Exception)">
            <summary>
            
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:EffectClasses.RAMException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:EffectClasses.HDMAException">
            <summary>
            
            </summary>
        </member>
        <member name="T:EffectClasses.DMAMode">
            <summary>
            DMA/HDMA uses a 1 byte value to dertermine how to transfer the data.
            <para>The last 3 bits of which indicate the transfere mode. How often and where to write the data</para>
            <para>The values 6 and 7 are a repeate of 2 and 3 respectively</para>
            </summary>
        </member>
        <member name="F:EffectClasses.DMAMode.P">
            <summary>
            1 register write once
            </summary>
        </member>
        <member name="F:EffectClasses.DMAMode.PP1">
            <summary>
            2 registers write once
            <para>p, p</para>
            </summary>
        </member>
        <member name="F:EffectClasses.DMAMode.PP">
            <summary>
            1 register write twice
            <para>p, p+1</para>
            </summary>
        </member>
        <member name="F:EffectClasses.DMAMode.PPP1P1">
            <summary>
            2 registers write twice
            <para>p, p, p+1, p+1</para>
            </summary>
        </member>
        <member name="F:EffectClasses.DMAMode.PP1P2P3">
            <summary>
            4 register write once
            <para>p, p+1, p+2, p+3</para>
            </summary>
        </member>
        <member name="F:EffectClasses.DMAMode.PP1PP1">
            <summary>
            2 registers write twice alternate
            <para>p, p+1, p, p+1</para>
            </summary>
        </member>
        <member name="T:EffectClasses.DMADirection">
            <summary>
            
            </summary>
        </member>
        <member name="F:EffectClasses.DMADirection.CPUtoPPU">
            <summary>
            
            </summary>
        </member>
        <member name="F:EffectClasses.DMADirection.PPUtoCPU">
            <summary>
            
            </summary>
        </member>
        <member name="T:EffectClasses.ColorPosition">
            <summary>
            Describes a 5bit color and where it is located vertically on the screen.
            </summary>
        </member>
        <member name="M:EffectClasses.ColorPosition.#ctor">
            <summary>
            Creates a new instance of a ColorPosition with it's Position and Value set to 0 (zero)
            </summary>
        </member>
        <member name="M:EffectClasses.ColorPosition.#ctor(System.Int32)">
            <summary>
            Creates a new instance of a ColorPosition with it's position preset and value set to 0 (zero)
            </summary>
            <param name="position">The position the color has on the screen</param>
        </member>
        <member name="M:EffectClasses.ColorPosition.#ctor(System.Int32,System.Byte)">
            <summary>
            Creates a new instance of a ColorPosition with it's Position and Value set to defined values
            </summary>
            <param name="position">The vertical position of the color on the screen</param>
            <param name="value8Bit">The 8bit value of the color</param>
        </member>
        <member name="M:EffectClasses.ColorPosition.CompareTo(EffectClasses.ColorPosition)">
            <summary>
            Compares two ColorPositions with each other and orders them by their position on the screen.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.ColorPosition.Equals(EffectClasses.ColorPosition)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.ColorPosition.Clone">
            <summary>
            Creates a ColorPosition element with the exact same values as this one.
            </summary>
            <returns>The newly created element</returns>
        </member>
        <member name="P:EffectClasses.ColorPosition.Orignal8Bit">
            <summary>
            Contains the originally set 8 bit value
            </summary>
        </member>
        <member name="P:EffectClasses.ColorPosition.Value5Bit">
            <summary>
            The 5bit value of the color used for the ASM
            </summary>
        </member>
        <member name="P:EffectClasses.ColorPosition.Value8Bit">
            <summary>
            The 8bit value of the color used for the actual color
            </summary>
        </member>
        <member name="P:EffectClasses.ColorPosition.Position">
            <summary>
            The position the color has on the screen
            </summary>
        </member>
        <member name="T:EffectClasses.ColorPositionCollection">
            <summary>
            A sorted collection of ColorPosition elements. Any newly added element will be sorted imediatelly as well
            </summary>
        </member>
        <member name="M:EffectClasses.ColorPositionCollection.#ctor">
            <summary>
            Creates a new instance of a ColorPositionCollection with the standard capacity
            </summary>
        </member>
        <member name="M:EffectClasses.ColorPositionCollection.#ctor(System.Int32)">
            <summary>
            Creates a new instance of a ColorPositionCollection with a preset capacity.
            </summary>
            <param name="capacity">The default capacity of the collection</param>
        </member>
        <member name="M:EffectClasses.ColorPositionCollection.#ctor(System.Collections.Generic.IEnumerable{EffectClasses.ColorPosition})">
            <summary>
            Creates a new instance of a ColorPositionCollection based of another ColorPositionCollection
            </summary>
            <param name="collection">The collection this instanze will be preinitialized with</param>
        </member>
        <member name="M:EffectClasses.ColorPositionCollection.IndexOf(System.Int32)">
            <summary>
            Will search through the collection to find the index of an item with a certain position.
            </summary>
            <param name="position">The position the item should have</param>
            <returns>The index of the found item or -1 if non was found.</returns>
        </member>
        <member name="M:EffectClasses.ColorPositionCollection.IndexOf(System.Int32,System.Int32)">
            <summary>
            Will search through the collection to find the index of an item with a certain position. Search starts at <paramref name="index"/>
            </summary>
            <param name="position">The position the item should have</param>
            <param name="index">The index from which the search should start</param>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if <paramref name="index"/> grows too large or small and exeeds the range of the collection</exception>
            <returns>The index of the found item or -1 if non was found.</returns>
        </member>
        <member name="M:EffectClasses.ColorPositionCollection.IndexOf(System.Int32,System.Int32,System.Int32)">
            <summary>
            Will search through the collection to find the index of an item with a certain position. Search starts at <paramref name="index"/> and looks through <paramref name="count"/> elements
            </summary>
            <param name="position">The position the item should have</param>
            <param name="index">The index from which the search should start</param>
            <param name="count">How many items should be checked</param>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if <paramref name="index"/> grows too large or small and exeeds the range of the collection</exception>
            <returns>The index of the found item or -1 if non was found.</returns>
        </member>
        <member name="M:EffectClasses.ColorPositionCollection.IndexOf(EffectClasses.ColorPosition)">
            <summary>
            Searches through the collection to find the index of a certain ColorPosition
            </summary>
            <param name="item">The ColorPosition element that should be searched for</param>
            <returns>The index of the found item or -1 if non was found.</returns>
        </member>
        <member name="M:EffectClasses.ColorPositionCollection.Insert(System.Int32,EffectClasses.ColorPosition)">
            <summary>
            Inserts a new ColorPosition object into the collection at a given index
            </summary>
            <param name="index">The index the ColorPosition should be inserted at</param>
            <param name="item">The ColorPosition to be added to the collection</param>
            <exception cref="T:System.Exception">Thrown if the collection already contains a ColorPosition with the same Position as <paramref name="item"/></exception>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if <paramref name="index"/> exeeds the range of the collection</exception>
        </member>
        <member name="M:EffectClasses.ColorPositionCollection.RemoveAt(System.Int32)">
            <summary>
            Removes a ColorPosition from the collection at a given index
            </summary>
            <param name="index">The index at which an object should be removed</param>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if <paramref name="index"/> exeeds the range of the collection</exception>
        </member>
        <member name="M:EffectClasses.ColorPositionCollection.Add(EffectClasses.ColorPosition)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:EffectClasses.ColorPositionCollection.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="M:EffectClasses.ColorPositionCollection.Contains(System.Int32)">
            <summary>
            Checks if the collection contains an item with the given position
            </summary>
            <param name="position">The position to be checked in the collection</param>
            <returns><c>True</c> if an item has been found</returns>
        </member>
        <member name="M:EffectClasses.ColorPositionCollection.Contains(EffectClasses.ColorPosition)">
            <summary>
            Checks if the collection contains a specific item
            </summary>
            <param name="item">The item to be checked in the collection</param>
            <returns><c>True</c> if an item has been found</returns>
        </member>
        <member name="M:EffectClasses.ColorPositionCollection.CopyTo(EffectClasses.ColorPosition[],System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:EffectClasses.ColorPositionCollection.Remove(EffectClasses.ColorPosition)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.ColorPositionCollection.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.ColorPositionCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:EffectClasses.ColorPositionCollection.Item(System.Int32)">
            <summary>
            Gets or sets the ColorPosition on a certain index.
            </summary>
            <param name="index">The index of the ColorPosition that should be changed</param>
            <returns>The ColorPosition at the given index</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if <paramref name="index"/> exeeds the range of the collection</exception>
        </member>
        <member name="P:EffectClasses.ColorPositionCollection.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:EffectClasses.ColorPositionCollection.IsReadOnly">
            <summary>
            
            </summary>
        </member>
        <member name="T:EffectClasses.ColorHDMAValues">
            <summary>
            The colors that can be used for various effects regarding the register $2132
            </summary>
        </member>
        <member name="F:EffectClasses.ColorHDMAValues.Red">
            <summary>
            The HDMA uses red (adds $20 to the the 5bit values)
            </summary>
        </member>
        <member name="F:EffectClasses.ColorHDMAValues.Green">
            <summary>
            The HDMA uses green (adds $40 to the the 5bit values)
            </summary>
        </member>
        <member name="F:EffectClasses.ColorHDMAValues.Blue">
            <summary>
            The HDMA uses blue (adds $80 to the the 5bit values)
            </summary>
        </member>
        <member name="T:EffectClasses.ColorHDMA">
            <summary>
            
            </summary>
        </member>
        <member name="M:EffectClasses.ColorHDMA.#ctor(EffectClasses.ColorHDMAValues)">
            <summary>
            
            </summary>
            <param name="color"></param>
        </member>
        <member name="M:EffectClasses.ColorHDMA.#ctor(EffectClasses.ColorHDMAValues,EffectClasses.ColorPositionCollection)">
            <summary>
            
            </summary>
            <param name="color"></param>
            <param name="collection"></param>
        </member>
        <member name="M:EffectClasses.ColorHDMA.UseCollection">
            <summary>
            
            </summary>
        </member>
        <member name="M:EffectClasses.ColorHDMA.UpdateImage">
            <summary>
            Generates the EffectImage based on the setting of the Table.
            </summary>
        </member>
        <member name="M:EffectClasses.ColorHDMA.FromString(System.String[],System.Boolean)">
            <summary>
            Draws the image and sets the internal table based on a string array.
            Returns every line that couldn't be translated.
            </summary>
            <param name="Lines">The lines that will be turned into an image</param>
            <param name="eightBit">Whether the values should be interpreted as 8 or 5 bit.</param>
            <returns>An array of error containing lines.</returns>
        </member>
        <member name="M:EffectClasses.ColorHDMA.IsEmpty">
            <summary>
            Checks if the color HDMA table contains date that verifies it's need in the final code
            </summary>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.ColorHDMA.CountRAMBytes">
            <summary>
            Calculates the total number of byte the code will later take up in the ROM
            </summary>
            <returns>The total amount of bytes that will be written to the RAM</returns>
        </member>
        <member name="M:EffectClasses.ColorHDMA.CountROMBytes">
            <summary>
            Calculates the total number of bytes the code will later take up in the ROM
            </summary>
            <returns>The total amount of bytes that will be written to the ROM</returns>
        </member>
        <member name="M:EffectClasses.ColorHDMA.Code(System.Int32,EffectClasses.HDMATable,System.Boolean)">
            <summary>
            
            </summary>
            <param name="channel"></param>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="P:EffectClasses.ColorHDMA.ColorsPositions">
            <summary>
            
            </summary>
        </member>
        <member name="P:EffectClasses.ColorHDMA.UsesMain">
            <summary>
            
            </summary>
        </member>
        <member name="P:EffectClasses.ColorHDMA.ColorEffect">
            <summary>
            
            </summary>
        </member>
        <member name="P:EffectClasses.ColorHDMA.EffectImage">
            <summary>
            The drawn gradient effect
            </summary>
        </member>
        <member name="T:EffectClasses.FullColorHDMA">
            <summary>
            
            </summary>
        </member>
        <member name="P:EffectClasses.ParallaxHDMA.Layers">
            <summary>
            Which register the effect code should work on
            </summary>
            <summary>
            Which register to use for the effect in the code
            </summary>
        </member>
        <member name="T:EffectClasses.LineBased`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:EffectClasses.LineBased`1.#ctor(System.Int32,`0)">
            <summary>
            
            </summary>
            <param name="lineCount"></param>
            <param name="value"></param>
        </member>
        <member name="P:EffectClasses.LineBased`1.LineCount">
            <summary>
            How many lines should be effected by T
            </summary>
        </member>
        <member name="P:EffectClasses.LineBased`1.Value">
            <summary>
            What should be
            </summary>
        </member>
        <member name="T:EffectClasses.ListLineBased`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:EffectClasses.Properties.Resources">
            <summary>
              Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
            </summary>
        </member>
        <member name="P:EffectClasses.Properties.Resources.ResourceManager">
            <summary>
              Gibt die zwischengespeicherte ResourceManager-Instanz zurück, die von dieser Klasse verwendet wird.
            </summary>
        </member>
        <member name="P:EffectClasses.Properties.Resources.Culture">
            <summary>
              Überschreibt die CurrentUICulture-Eigenschaft des aktuellen Threads für alle
              Ressourcenzuordnungen, die diese stark typisierte Ressourcenklasse verwenden.
            </summary>
        </member>
        <member name="T:EffectClasses.TableValueType">
            <summary>
            Describes what format the values of an ASMTableEntry have or in what format they should be written
            </summary>
        </member>
        <member name="F:EffectClasses.TableValueType.db">
            <summary>
            Value is one byte long or will be written in seperate bytes
            </summary>
        </member>
        <member name="F:EffectClasses.TableValueType.dw">
            <summary>
            Value is one word (2 bytes) long or will be written in two byte patterns
            </summary>
        </member>
        <member name="F:EffectClasses.TableValueType.dl">
            <summary>
            Values is long (3 bytes) or will be written in three byte patterns
            </summary>
        </member>
        <member name="F:EffectClasses.TableValueType.dd">
            <summary>
            Values is double (4 bytes) or will be written in four byte patterns
            </summary>
        </member>
        <member name="F:EffectClasses.TableValueType.Single">
            <summary>
            Each value entry will be used for one scanline, the lenght can vary.
            <para>This cannot be used to write tables.</para>
            </summary>
        </member>
        <member name="F:EffectClasses.TableValueType.End">
            <summary>
            Last entry in a table, there are no values nor scanlines 
            </summary>
        </member>
        <member name="T:EffectClasses.TableValueStringArgument">
            <summary>
            
            </summary>
        </member>
        <member name="F:EffectClasses.TableValueStringArgument.Dollar">
            <summary>
            Writes a dollar symbol infront of all the values and the scanline
            </summary>
        </member>
        <member name="F:EffectClasses.TableValueStringArgument.Direct">
            <summary>
            Writes the db, dw or dl and adds a colon when the type changes
            </summary>
        </member>
        <member name="F:EffectClasses.TableValueStringArgument.Comma">
            <summary>
            Writes a comma + space inbetween the single values and scanline
            </summary>
        </member>
        <member name="F:EffectClasses.TableValueStringArgument.Standart">
            <summary>
            A combination of Dollar, Direct and Comma
            </summary>
        </member>
        <member name="T:EffectClasses.ASMTableEntry">
            <summary>
            One entry of an ASMTable.
            </summary>
        </member>
        <member name="M:EffectClasses.ASMTableEntry.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:EffectClasses.ASMTableEntry.#ctor(System.Byte[])">
            <summary>
            Creates a new instance of an ASMTableEntry 
            </summary>
            <param name="values"></param>
        </member>
        <member name="M:EffectClasses.ASMTableEntry.Clone">
            <summary>
            Creates a copy of the ASMTableEntry
            </summary>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.ASMTableEntry.Equals(EffectClasses.ASMTableEntry)">
            <summary>
            checks if two ASMTableEntries are equal to each other.
            </summary>
            <param name="obther">The other entry to be compared</param>
            <returns><c>True</c> if they are equal</returns>
        </member>
        <member name="M:EffectClasses.ASMTableEntry.Equals(System.Object)">
            <summary>
            checks if an object is equal to this ASMTableEntry
            </summary>
            <param name="obj">The object to be compared</param>
            <returns><c>True</c> if they are equal</returns>
        </member>
        <member name="M:EffectClasses.ASMTableEntry.GetHashCode">
            <summary>
            Get the hash code based on the values
            </summary>
            <returns>A hash code to identify the object.</returns>
        </member>
        <member name="M:EffectClasses.ASMTableEntry.ToString">
            <summary>
            Creates an ASM conform string for an table entry from the stored values.
            </summary>
            <returns>The combined string of thr values</returns>
        </member>
        <member name="M:EffectClasses.ASMTableEntry.ToString(EffectClasses.TableValueType)">
            <summary>
            Creates an ASM conform string for an table entry from the stored values.
            </summary>
            <param name="type">Which format to use for the table.</param>
            <returns>The combined string of thr values</returns>
        </member>
        <member name="T:EffectClasses.ASMTable">
            <summary>
            
            </summary>
        </member>
        <member name="T:EffectClasses.HDMATableEntry">
            <summary>
            
            </summary>
        </member>
        <member name="M:EffectClasses.HDMATableEntry.#ctor(EffectClasses.TableValueType)">
            <summary>
            
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:EffectClasses.HDMATableEntry.#ctor(EffectClasses.TableValueType,System.Byte,System.Byte[])">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="scanlines"></param>
            <param name="values"></param>
        </member>
        <member name="M:EffectClasses.HDMATableEntry.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.HDMATableEntry.ToString(EffectClasses.TableValueType)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.HDMATableEntry.Equals(System.Object)">
            <summary>
            Compares and object to the current object and checks if they have the same content
            </summary>
            <param name="obj">The object to compare with</param>
            <returns>True if the members of both HDMATableEntries are the same</returns>
        </member>
        <member name="M:EffectClasses.HDMATableEntry.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.HDMATableEntry.op_Equality(EffectClasses.HDMATableEntry,EffectClasses.HDMATableEntry)">
            <summary>
            Compares two HDMATableEntry values and checks if they are equal down to the last entry.
            </summary>
            <param name="t1">The first object to be compared</param>
            <param name="t2">The second object to be compared</param>
            <returns><c>True</c> if they are equal</returns>
        </member>
        <member name="M:EffectClasses.HDMATableEntry.op_Inequality(EffectClasses.HDMATableEntry,EffectClasses.HDMATableEntry)">
            <summary>
            Compares two HDMATableEntry values and checks if they are NOT equal even in only on entry.
            </summary>
            <param name="t1">The first object to be compared</param>
            <param name="t2">The second object to be compared</param>
            <returns><c>True</c> if the objects are not the same.</returns>
        </member>
        <member name="M:EffectClasses.HDMATableEntry.Clone">
            <summary>
            Creates a dublicate of the current objects and all it's members
            </summary>
            <returns>An object that needs to be casted containing the same members as this</returns>
        </member>
        <member name="M:EffectClasses.HDMATableEntry.Equals(EffectClasses.HDMATableEntry)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="P:EffectClasses.HDMATableEntry.End">
            <summary>
            The last table entry in an HDMA table
            </summary>
        </member>
        <member name="P:EffectClasses.HDMATableEntry.ValueType">
            <summary>
            Defines what type of value this entry stores
            </summary>
        </member>
        <member name="P:EffectClasses.HDMATableEntry.Scanlines">
            <summary>
            The number of scanlines that should be effected
            </summary>
        </member>
        <member name="P:EffectClasses.HDMATableEntry.Values">
            <summary>
            The Values that are used for the effect. How many values can be set depends on ValueType.
            </summary>
        </member>
        <member name="T:EffectClasses.HDMATable">
            <summary>
            
            </summary>
        </member>
        <member name="M:EffectClasses.HDMATable.HasEnded">
            <summary>
            Indicates if the table already has an End entry at it's end
            </summary>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.HDMATable.IndexOf(EffectClasses.HDMATableEntry)">
            <summary>
            Gets the first index of a certain element within the table
            </summary>
            <param name="item">The HDMATableEntry to be found in the table</param>
            <returns>The indes of the first match </returns>
        </member>
        <member name="M:EffectClasses.HDMATable.Insert(System.Int32,EffectClasses.HDMATableEntry)">
            <summary>
            Insert an entry somewhere in the table.
            <para>Trying to insert an End entry anywhere other than at the end will result in an excpetion</para>
            </summary>
            <param name="index">The position the element should be added in</param>
            <param name="item">The entry to be added to the table</param>
        </member>
        <member name="M:EffectClasses.HDMATable.RemoveAt(System.Int32)">
            <summary>
            Remove an element at a certain position within the table
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:EffectClasses.HDMATable.Add(EffectClasses.HDMATableEntry)">
            <summary>
            Add new tableentry at the end of the table
            </summary>
            <param name="item">entry to be added</param>
            <exception cref="T:System.Exception">Thrown when you try to add entries after an End-entry</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if item is null</exception>
        </member>
        <member name="M:EffectClasses.HDMATable.Clear">
            <summary>
            Remove all entries from the table
            </summary>
        </member>
        <member name="M:EffectClasses.HDMATable.Contains(EffectClasses.HDMATableEntry)">
            <summary>
            Checks if the table contains a certain entry.
            </summary>
            <param name="item">The entry that should be checked</param>
            <returns>True if the table does contain said entry</returns>
        </member>
        <member name="M:EffectClasses.HDMATable.CopyTo(EffectClasses.HDMATableEntry[],System.Int32)">
            <summary>
            Copies the table into an array of HDMATableEntries and starts at a specific index
            </summary>
            <param name="array">The array to be filled with the entries</param>
            <param name="arrayIndex">The index from which the data will be copied into the array</param>
        </member>
        <member name="M:EffectClasses.HDMATable.Remove(EffectClasses.HDMATableEntry)">
            <summary>
            Removes the first instance of an item from the table
            </summary>
            <param name="item">item to be removed</param>
            <returns>True if an item was successfully removed</returns>
        </member>
        <member name="M:EffectClasses.HDMATable.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:EffectClasses.HDMATable.Clone">
            <summary>
            Creates a HDMATable instance that has the exact same values as this one
            </summary>
            <returns>The object that can be casted to an HDMATable</returns>
        </member>
        <member name="P:EffectClasses.HDMATable.TotalScanlines">
            <summary>
            The total number of scanlines the table takes up.
            </summary>
        </member>
        <member name="P:EffectClasses.HDMATable.TotalBytes">
            <summary>
            The total number of bytes the table will take up when inserted into the ROM
            </summary>
        </member>
        <member name="P:EffectClasses.HDMATable.Item(System.Int32)">
            <summary>
            Gets or sets the entry at a certain position
            </summary>
            <param name="index">The position at which an entry should be edited</param>
            <returns>The to be edited entry</returns>
        </member>
        <member name="P:EffectClasses.HDMATable.Count">
            <summary>
            How many tableentries are there
            </summary>
        </member>
        <member name="P:EffectClasses.HDMATable.IsReadOnly">
            <summary>
            Whether or not data can only be read
            </summary>
        </member>
    </members>
</doc>
